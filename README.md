# FormalLanguagesPrac1Task12
Проект можно скомпилировать с помощью g++ main.cpp RPNparser.cpp -o exe

Описание и корректность алгоритма: из регулярного выражения в обратной польской нотации построим НКА с одним начальным и конечным состояниям. После этого сделаем в нем обход (например, в глубину) от финиша к старту т. е. в обратную сторону по каждому ребру, помечая пары вида: вершина автомата, номер позиции во входном слове. Во время обхода будем обновлять ответ, когда достигнем пар: старт автомата, какая-то позиция в слове. Начнем обход из пары: финиш, позиция в слове за последней буквой. При переходе по EPS не будем сдвигаться в слове, а переход по букве будем совершать только в случае совпадения буквы в вершине автомата и текущей обозреваемой буквы в слове. Покажем, как выполнить алгоритм за O(|L|\*|W|). Сначала покажем как построить НКА за O(|L|) времени и столько же памяти. Для каждой вершины храним список ребер в нее входящих. В стеке будем собирать автомат, объединяя подграфы. Для этого будем поддерживать инвариант: каждый подграф имеет одну начальную и конечную вершину, пары которых и будут храниться в стеке разбора. Когда в текущий момент разбирается символ A из алфавита, создаем 3 новых вершины: EPS->A->EPS. А в стек кладем пару указателей: левая EPS и правая EPS(В случае ввода '1' достаточно создавать всего одну вершину EPS). Когда встречаем '.', достаем из стека 2 верхних элемента: (L1,R1), (L2,R2). Создаем ребро R1->L2. А в стек кладем (L1,R2). При сложении аналогично проставляем ребра: R1->R2, L2->L1. В стек кладем (L1,R1). При '\*' достаем верхний элемент стека и ставим ребра: L1->R1, R1->L1. Стартом и финишем соответственно назначаем элементы единственной пары в стеке. Заметим, что вершин автомата <= 3\*|L| = O(|L|). Видно, что всего шагов построения также O(|L|). И на каждом из них добавляется <= 2 ребра. Следовательно ДКА линеен по времени построения и памяти. Теперь совершим обход в нем: состояний обхода O(|L|\*|W|), каждое ребро можно пройти <= |W| раз. А так как обход в глубину работает за O(|V| + |E|) то, следовательно суммарное время обхода: O(|L|\*|W|). Что и требовалось. Корректность очевидна: для каждого разбираемого выражением суффикса обход дойдет до состояния (старт, |W| - |SuffixSize|) и обновит максимум.

Легко видеть, что оценку времени работы данного алгоритма улучшить нельзя, так как она достигается на выражении abc++*
